#!/usr/bin/env python2.7
from SocketServer import StreamRequestHandler, TCPServer
import subprocess
import threading
import time
import sys
import os
import io

LLD_NAME = 'SDC_IO'

def sim_format(lld, data):
  return '%s\t%s\n' % (lld , data.encode('hex'))

class SIMIO(StreamRequestHandler):
  def handle(self):
    print '[SIMIO] CONNECT'
    while True:
      self.read_line()

  def read_line(self):
    # get io data
    line = self.rfile.readline()
    if not line:
      sys.stdout.write('[%s] EOF\n' % LLD_NAME)

    header, code = line.strip().split('\t', 1)

    # decode io data
    metadata = code.decode('hex')
    sys.stdout.write('[%s] RECV %s\n' % (header, metadata))

    # parse sdc message
    cmd, offset, length = metadata.split(' ', 2)
    offset = int(offset, 16)
    length = int(length, 16)

    # handle offset seek
    memfile.seek(offset, os.SEEK_SET)

    # sdc asked to read data
    if cmd == 'read':
      # get requested data
      data = memfile.read(length)
      sys.stdout.write('[%s] READ %r\n' % ('MEMORY', data))

      # send data back to sdc
      sys.stdout.write('[%s] SEND %r\n' % (header, data))
      self.wfile.write(sim_format(LLD_NAME, data))

    # sdc asked to write data
    elif cmd == 'write':
      # read and decode another io message that contains the data
      line = self.rfile.readline()
      header, code = line.strip().split('\t', 1)
      data = code.decode('hex')

      # store the data
      sys.stdout.write('[%s] WRITE %r\n' % ('MEMORY', data))
      memfile.write(data)

memfile = io.BytesIO()
for i in range(5):
  memfile.write('\0x0')

# prevent bind errors on relaunch
TCPServer.allow_reuse_address = True

# listen for simio connections
simio = TCPServer(('localhost', 27000), SIMIO)
simio_thread = threading.Thread(target=simio.handle_request)
simio_thread.setDaemon(True)
simio_thread.start()

# spawn the unit test
subprocess.check_call(['./ch'])
